from openai import OpenAI
import logging
from vosk import Model, KaldiRecognizer
import wave
import json
from pydub import AudioSegment
import os
from icrawler.builtin import GoogleImageCrawler
import voicegenerator
from pydantic import BaseModel

logging.getLogger().setLevel(logging.CRITICAL)
class Scene(BaseModel):
    start_time: float
    end_time: float
    prompt: str
    narration: str
class Video(BaseModel):
    scenes: list[Scene]


client = OpenAI(
    api_key=
)

def getCustomScript(context):
    logging.warning("(API Notification) API call made to chatgpt to fetch script on %s!" % context)
    completion = client.beta.chat.completions.parse(
    model="gpt-4o-mini",
    messages=[
        {"role": "system", "content": "You are a history enthusiast and an avid social media content creator and you will adhere to the response structure for a video with atleast 10 scenes to follow the instructions given to create a director like script."},
        {"role": "user", "content": "Give script with all the key details about %s, Try to describe the image prompts in about 100 words each to be generated by dall-e-3. It is Key to ensure that the entire narration can be done within 60 seconds and not more." % context}
    ],
    response_format=Video
    )
    response =  completion.choices[0].message
    if response.refusal:
        logging.warning("(API Notification) ChatGPT refused to return script according to structure passed. %s" % response.refusal)
        return None
    else:
        return response.parsed
def generateImage(prompt):
    response = client.images.generate(
    model="dall-e-3",
    prompt=prompt,
    size="1024x1792",
    quality="standard",
    n=1,
    )

    return response.data[0].url
def getHistoryScript(context):
    logging.warning("(API Notification) API call made to chatgpt to fetch script on %s!" % context)
    completion = client.chat.completions.create(
    model="gpt-4o-mini",
    messages=[
        {"role": "system", "content": "You are a history enthusiast and an avid social media content creator and you will follow the instructions given to create a director like script."},
        {"role": "user", "content": "Give script with all the key details about %s that can be narrated in 60 second shorts video with prompts like images, visuals, etc. enclosed in square brackets in between each speech line except narrator speech which will be as; Narrator:, followed by speech (in quotes) " % context}
    ]
    )
    return completion.choices[0].message.content
def chat(messages, message=""):
    
    logging.warning("(API Notification) API call made to chatgpt to chat!")
    if message != "":
        messages.append({"role":"user", "content":message})
    else:
        messages.append({"role":"user", "content": "Read the session transcript and give the topic for which a summary video should be generated. Only give the title in about 5 words"})

    completion = client.chat.completions.create(
    model="gpt-4o-mini",
        messages = messages
    )

    response = completion.choices[0].message.content
    messages.append({"role":"system", "content":response})
    return messages
def getHistorySpeech(context, state, data):

    if state:
        prompt = """give a summary about what the user needs based on the query:%s, in 150 words or less  while following the instructions given below, 
                    NOTE: Also do not use any complex english words in the summary, instead use simple words that are easy to understand.
                    1. The opening of the story or the "hook" should grab the viewer's attention. The hook should be a short, concise statement that 
                    is compelling; for example, it could be a question that is posed to the viewer; so that the viewer can relate to the story; or it could be something hair-raising, surprising or 
                    controversial. The hook should be something that the viewer would want to know more about, essentially it should be a hook that will make the viewer want to watch the rest of the video. 
                    2. It is very important that the story has a message or lesson that the viewer can take away but is hidden subtly and not forced upon the viewer. 
                    3. Use storytelling techniques to make the content more compelling and ensure that the narrative aligns with the overarching theme of the story. 
                    4. The summary should be designed to be educational and pleasing to watch.
                    """ % context
    else:
        prompt = """give a summary about what the user needs based on the query:%s, the similarity scores from our database are: %s (if any), in 150 words or less  while following the instructions given below, 
                    NOTE: Also do not use any complex english words in the summary, instead use simple words that are easy to understand.
                    1. The opening of the story or the "hook" should grab the viewer's attention. The hook should be a short, concise statement that 
                    is compelling; for example, it could be a question that is posed to the viewer; so that the viewer can relate to the story; or it could be something hair-raising, surprising or 
                    controversial. The hook should be something that the viewer would want to know more about, essentially it should be a hook that will make the viewer want to watch the rest of the video. 
                    2. It is very important that the story has a message or lesson that the viewer can take away but is hidden subtly and not forced upon the viewer. 
                    3. Use storytelling techniques to make the content more compelling and ensure that the narrative aligns with the overarching theme of the story. 
                    4. The summary should be designed to be educational and pleasing to watch.
                    5. Ensure the scene times are continuous and the total length of the scenes is about 60 seconds.
                    """ % (context, data)



    logging.warning("(API Notification) API call made to chatgpt to fetch speech on %s!" % context)
    completion = client.chat.completions.create(
    model="gpt-4o-mini",
    messages=[
        {"role": "system", "content": "You are a history enthusiast and an avid social media content creator and you will follow the instructions given to form a speech with engaging story flow."},
        {"role": "user", "content": prompt}
    ]
    )
    return completion.choices[0].message.content
def getNewsArticleSummary(article):
    logging.warning("(API Notification) API call made to chatgpt to fetch summary for article!")
    completion = client.chat.completions.create(
    model="gpt-4o-mini",
    messages=[
        {"role": "system", "content": "You are a news enthusiast and an avid social media content creator and you will prepare a summary for the following prompt."},
        {"role": "user", "content": "%s Create a summary to be used as a speech with as many words that can be spoken within 50 seconds while preserving integrity and details." % article}
    ]
    )
    return completion.choices[0].message.content
def getKeywordsFromSummary(summary):
    logging.warning("(API Notification) API call made to chatgpt to fetch keywords for summary!")
    completion = client.chat.completions.create(
    model="gpt-4o-mini",
    messages=[
        {"role": "system", "content": "You are a news enthusiast and an avid social media content creator."},
        {"role": "user", "content": "%s What are 5 images for this article (in order of appearance) that can be used as images in the background of a video for this article?" % summary}
    ]
    )
    return completion.choices[0].message.content
def getTranscript(path_to_speech_file, form = "verbose_json", granularity="word", speech=None):
    logging.warning("(API Notification) API call made to chatgpt to fetch transcript for audio file at %s!" % (path_to_speech_file))
    with open(path_to_speech_file, "rb") as file:
        if speech!=None:
            transcript = client.audio.transcriptions.create(
            prompt=speech,
            language="en",
            file=file,
            model="whisper-1",
            response_format=form,
            timestamp_granularities=[granularity]
            )
        else:
            transcript = client.audio.transcriptions.create(
            language="en",
            file=file,
            model="whisper-1",
            response_format=form,
            timestamp_granularities=[granularity]
            )
    return transcript
def generateVoiceOver(text, path_to_speech_file, tone="Wacky"):
    voices = {"Narrator": "en_male_narration", "Peaceful": "en_female_emotional", "Wacky": "en_male_funny", "Serious":"en_male_cody"}
    if tone not in voices.keys():
        voice = tone
    else:
        voice = voices[tone]
    voicegenerator.tts(text, voice, path_to_speech_file)
def getTitleAndDescription(text):
    logging.warning("(API Notification) API call made to chatgpt to fetch title and description for video!")
    completion = client.chat.completions.create(
    model="gpt-4o-mini",
    messages=[
        {"role": "system", "content": "You are a history enthusiast and an avid social media content creator."},
        {"role": "user", "content": "%s The above is the script to a short video, what is the appropriate title and description to this video that will be highly engaging to viewers?" % text}
    ]
    )
    return completion.choices[0].message.content
def getvideoparams(context):
    logging.warning("(API Notification) API call made to chatgpt to fetch video parameters on %s!" % context)
    completion = client.chat.completions.create(
    model="gpt-4o-mini",
    messages=[
        {"role": "system", "content": "You are a history enthusiast and an avid social media content creator."},
        {"role": "user", "content": "Write the video title, short description and tags that can be put into youtube for a shorts video about %s." % context}
    ]
    )
    return completion.choices[0].message.content
def getHistoryIdeas(slice):
    logging.warning("(API Notification) API call made to chatgpt to fetch history video ideas!")
    completion = client.chat.completions.create(
    model="gpt-4o-mini",
    messages=[
        {"role": "system", "content": "You are a history enthusiast and an avid social media content creator."},
        {"role": "user", "content": "List upto 50 events including wars, technological advancements, key events, cultural events, economic events that occured in the years from %s to %s %s that can be made into short videos." % (slice.split("-")[0], slice.split("-")[1].split(" ")[0], slice.split("-")[1].split(" ")[1])}
    ]
    )
    return [i.message.content for i in completion.choices]

def getsentiment(text):
    logging.warning("(API Notification) API call made to chatgpt to fetch script sentiment!")
    completion = client.chat.completions.create(
    model="gpt-4o-mini",
    messages=[
        {"role": "system", "content": "You are a history enthusiast and an avid social media content creator."},
        {"role": "user", "content": "Given is the narrator script for a video: %s. Choose a sentiment for the background music out of Intriguing, Somber or Upbeat." % text}
    ]
    )
    return completion.choices[0].message.content
def tts(text, context, speech_file_path):
    logging.warning("(API Notification) API call made to chatgpt to generate speech on %s!" % context)
    response = client.audio.speech.create(
    model="tts-1",
    voice="onyx",
    input=text
    )
    response.stream_to_file(speech_file_path)

def transcribe(context):
    if "%s.wav" % context not in os.listdir("history/audio"):
        logging.warn("(Transcription Notification) The mp3 file for %s could not be found! converting..." % context)
        sound = AudioSegment.from_mp3("history/audio/%s.mp3" % context)
        sound.export("history/audio/%s.wav" % context, format="wav")
    wf = wave.open("history/audio/%s.wav" % context, "rb")
    rec = KaldiRecognizer(Model(model_name="vosk-model-en-us-0.22-lgraph"), wf.getframerate())
    rec.SetWords(True)
    results = []
    while True:
        data = wf.readframes(4000)
        if len(data) == 0:
            break
        if rec.AcceptWaveform(data):
            part_result = json.loads(rec.Result())
            results.append(part_result)
    part_result = json.loads(rec.FinalResult())
    results.append(part_result)
    return results

def generateimages(context, directory, search):
    def getmaxid(context=context, directory=directory):
        count = 0
        for i in os.listdir(directory):
            if context in i:
                count += 1
        return count
    google_Crawler = GoogleImageCrawler(storage = {'root_dir': directory})
    google_Crawler.crawl(keyword = search, max_num = 1)

    for i in os.listdir(directory):
        if context not in i:
            try:
                test = int(i.split(".")[0])
                os.rename(directory+"/"+i, directory+"/"+"%s %d.%s" % (context, getmaxid(), i.split(".")[1]))
            except:
                pass
